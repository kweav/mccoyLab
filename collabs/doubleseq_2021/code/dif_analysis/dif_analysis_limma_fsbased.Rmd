---
title: "dif_analysis_limma_fsbased"
author: "Kate Weaver"
date: "1/17/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load_packages, message=FALSE}
library(limma)
library(SummarizedExperiment)
library(rtracklayer)
library(tidyverse)
library(data.table)
library(readxl)
library(janitor)
library(ggrepel)
library(ggthemes)
library(edgeR)
library(plotly)
library(survcomp)
library(cowplot)
library(AnnotationDbi)
library(EnsDb.Hsapiens.v86)
library(ggplot2)
```

```{r set_params}
qval <- 0.1
```

### Load data

importing SummarizedExperiment Data and transforming to raw counts data
```{r load_data_se}
load("~/mccoyLab/collabs/doubleseq_2021/summarized_experiment/create_summarized_experiment_allNov2021.Rdata")
counts <- as.matrix(assays(seAll)$counts)
for (col in 1:ncol(counts)){
  colnames(counts)[col]<-strsplit(sub("Aligned.sortedByCoord.out.bam", "", colnames(counts)[col]), "_")[[1]][1]
}
```

```{r, load_metaandsubsetby_sets}
#subset to just training data/samples
embryoID_by_set <- read.csv("~/mccoyLab/collabs/doubleseq_2021/data_split/embryo_bySet_full_kw_20211217.csv", col.names=c("embryoID", "set"))
train_embryoIDs = embryoID_by_set$embryoID[embryoID_by_set$set == "train"]

#Importing metadata to differentiate between pregnant and not pregnant and other main covariates
meta <- read.csv("~/mccoyLab/collabs/doubleseq_2021/tidied_meta/tidied_meta_CREATE_kw_20211217.csv", row.names = 1) %>% 
  as.data.frame() %>% 
  mutate(across(c("AOD", "GC", "Infertility_type", "Previous_pregnancy", "Past_surgical_hist", "Pregnant", "Ongoing_pregnancy", "Final_outcome", "Embryo_grade_at_freezing", "Interpretation", "cDNA_RT_Date", "Library_Prep_Date", "Sequencing_Date", "Study_Participant_ID"), as.factor)) %>%
  mutate(across(c("InfD_SSM_GC", "InfD_Egg_factor", "InfD_MF", "InfD_Uterine_factor", "InfD_TF", "InfD_RPL", "InfD_RIF", "InfD_Unexplained", "PMdH_none", "PMdH_vasculitis", "PMdH_immune", "PMdH_stress_hormones"), as.factor))

# subset to just train embryos, regardless if there is matching sequencing data or not
meta <- meta[train_embryoIDs,] #118 samples
```

### Feature Selection just based on outcome

```{r find_vars_with_na}
df_to_plot <- data.frame(x = colSums(is.na(meta)), variable=colnames(meta))
df_to_plot$bool_var <- df_to_plot$x > 0

whichones <- which(df_to_plot$bool_var == TRUE)
df_to_plot$variable[whichones]
```

```{r find_factor_vars_with_lt2_levels}
df_to_plot <- data.frame(x = unlist(lapply(1:ncol(meta), function(x) length(unique(meta[,x])))), variable=colnames(meta))
df_to_plot$bool_var <- df_to_plot$x >= 2
whichones <- which(df_to_plot$bool_var == FALSE)
df_to_plot$variable[whichones]
```

select only relevant columns
```{r}
columns_to_remove <- c("Ongoing_pregnancy", "Final_outcome",
                       "Time_to_OPU_hr", "Time_to_stripping_hr", "Time_to_ICSI_hr", "Time_to_Biopsy_hr", "AMH",
                       "Sildenafil")
to_remove <- which(colnames(meta) %in% columns_to_remove)


meta_covs <- meta[,-to_remove]
meta_covs$Pregnant=meta_covs$Pregnant==1
```


```{r, setup_eq, warning=FALSE}
intercept_only <- glm(Pregnant ~ 1, data = meta_covs, family=binomial)
all <- glm(Pregnant ~ ., data=meta_covs, family=binomial)
```

```{r, forward, warning=FALSE}
forward <- step(intercept_only, direction='forward', scope=formula(all), trace=0)
forward$anova
summary(forward)
```

### Further data subsetting

```{r further_subset_embryos}
#subsetting embryos to include only ones with sequencing data            
remove <- setdiff(train_embryoIDs, colnames(counts))
if (length(which(rownames(meta) %in%  remove)) > 0){
  train_embryoIDs <- train_embryoIDs[-which(train_embryoIDs %in% remove)]
}

#subsetting meta and counts data to just the training rows            
meta_covs <- meta_covs[train_embryoIDs,]
counts <- as.matrix(t(as.data.frame(t(counts))[train_embryoIDs,]))

#need to sort so name order is the same for setting up design for DESeq experiment
counts_order <- order(colnames(counts))
meta_order <- order(rownames(meta_covs))

countdata <- counts[, counts_order]
meta_covs <- meta_covs[meta_order, ] #107 samples
```


```{r load_andsubsetby_gencode}
#subset to genes with matchind gencode ensembl gene IDs on chr1-22
file_gencode <- "~/genomes/hg38_genome/gencode.v34.annotation.gtf"

gtf <- rtracklayer::import(file_gencode) %>% 
  as.data.frame() %>% 
  dplyr::filter(type == "gene") %>% 
  dplyr::select(gene_id, seqnames, width) %>% 
  dplyr::rename(ensembl_gene_id = gene_id) %>% 
  dplyr::rename(chromosome_name = seqnames) %>% 
  dplyr::rename(length = width)

gene_table <- gtf[match(rownames(countdata), gtf$ensembl_gene_id),]
gene_table <- gene_table[gene_table$chromosome_name %in% paste0("chr", 1:22),]
countdata <- countdata[gene_table$ensembl_gene_id,]

```


### Differential expression analysis

```{r filter_expression}
#Use stringent filtering
dgeFullData <- DGEList(countdata, group=as.factor(meta_covs$Study_Participant_ID))
#normalize counts by TMM
TMMFullData <- calcNormFactors(dgeFullData, method="TMM")
TMMCounts <- as.matrix(TMMFullData$counts)
countsCleaned <- TMMCounts[rowSums(TMMCounts >= 6) > (ncol(TMMCounts)* .2),]

#TPM Calculation
calc_tpm <- function(x, gene.length) {
  x <- as.matrix(x)
  len.norm.lib.size <- colSums(x / gene.length)
  return((t(t(x) / len.norm.lib.size) * 1e06)/ gene.length)
}

#creates a matrix with calculated TPM values for each sample from TMM normalized counts and the gene lengths
rawTPMvals <- calc_tpm(TMMFullData, gene.length = gene_table$length)
cleanedTPMVals <- rawTPMvals[rowSums(rawTPMvals > 0.1) > (ncol(rawTPMvals)*.2),]
cleanCountsDf <- as.data.frame(countsCleaned)
cleanTPMdf <- as.data.frame(cleanedTPMVals)

#select just counts that passed both stringent filters
countdata <- cbind(countdata[intersect(rownames(cleanCountsDf), rownames(cleanTPMdf)),])
```

```{r, difexp_design}
design <- model.matrix(forward$formula, data=meta_covs)
```

```{r, difexp}
dge <- edgeR::DGEList(counts = countdata, samples = meta_covs)
#log counts per million and use of prior.count to damp down the variance of logs of low counts
logCPM <- edgeR::cpm(dge, log=TRUE, prior.count=3)
#requires statmod package
corfit <- duplicateCorrelation(logCPM, design=design, ndups=1, block=meta_covs$Study_Participant_ID) # A slow computation
message(corfit$consensus.correlation)
g <- boxplot(tanh(corfit$atanh.correlations))
g

v <- limma::voom(dge, design, plot=TRUE, save.plot = TRUE)
v
save(v, file="~/mccoyLab/collabs/doubleseq_2021/dif_expression_results/voomOut_trainSPA_featselect_withBatch.Rdata")

fit <- lmFit(v, design, correlation = corfit$consensus)
fit
fit <- eBayes(fit)
res = topTable(fit, n=Inf, sort="p", coef=2)

#exporting all genes
write.csv(as.data.frame(res), file="~/mccoyLab/collabs/doubleseq_2021/dif_expression_results/results_trainSPA_featselect_withBatch.all.csv")
```

```{r plots}
ggplot(res, aes(x=1, y=adj.P.Val)) + geom_boxplot() + theme_bw() + theme(panel.grid = element_blank(), panel.background = element_blank()) + xlab("") + theme(axis.text.x=element_blank(), axis.ticks.x=element_blank())

ggplot(res, aes(x=1, y=adj.P.Val)) + geom_jitter(width=0.3, height=0) + theme_bw() + theme(panel.grid = element_blank(), panel.background = element_blank()) + xlab("") + theme(axis.text.x=element_blank(), axis.ticks.x=element_blank())

#mapping from ENSEMBL Gene ID to SYMBOL and ENTREZ
ens.str <- substr(rownames(res), 1, 15)
edb <- EnsDb.Hsapiens.v86
res$symbol <- mapIds(edb, keys=ens.str, column="SYMBOL", keytype="GENEID", multiVals="first")
res$entrez <- mapIds(edb, keys=ens.str, column="ENTREZID", keytype="GENEID", multiVals="first")

```


```{r use_qval}
res.qval <- subset(res, adj.P.Val<qval) %>% 
  as.data.frame()
write.csv(res.qval, file = "~/mccoyLab/collabs/doubleseq_2021/dif_expression_results/results_trainSPA_featselect_withBatch.qval.csv")

ggplot(res.qval, aes(x=1, y=adj.P.Val)) + geom_jitter(width=0.1, height=0) + theme_bw() + theme(panel.grid = element_blank(), panel.background = element_blank()) + xlab("") + theme(axis.text.x=element_blank(), axis.ticks.x=element_blank())

#plotting volcano plot
res.qval$diffexpressed <- "NO"
res.qval$diffexpressed[res.qval$logFC > 2 & res.qval$adj.P.Val < qval] <- "UP"
res.qval$diffexpressed[res.qval$logFC < -2 & res.qval$adj.P.Val < qval] <- "DOWN"

g0 <-  ggplot(data = res, aes(x=logFC, y=-log10(adj.P.Val))) + geom_point(size=0.5) + theme_classic()
g0 <- g0 + theme(panel.grid.major = element_line(color="gray70", size=0.3, linetype=3)) + geom_vline(xintercept=c(-2,2), col="green4") + geom_hline(yintercept=-log10(qval), col="green4")
g0

g <- ggplot(data=res.qval, aes(x=logFC, y=-log10(adj.P.Val), col=diffexpressed)) + geom_point(size=0.5) + theme_classic()
g <- g + theme(panel.grid.major = element_line(color="gray70", size=0.3, linetype=3)) + geom_vline(xintercept=c(-2,2), col="green4") + geom_hline(yintercept=-log10(qval), col="green4")
g

g1 <- g + scale_color_manual(values=c("blue", "gray", "red"))

res.qval$delabel <- NA
res.qval$delabel[res.qval$diffexpressed != "NO"] <- res.qval$symbol[res.qval$diffexpressed != "NO"]

g1 <- ggplot(data = res.qval, aes(x=logFC, y=-log10(adj.P.Val), col=diffexpressed, label=delabel)) +
  geom_point() +
  theme_minimal() +
  geom_text_repel() +
  scale_color_manual(values=c("blue", "black", "red")) +
  geom_vline(xintercept=c(-0.6, 0.6), col="red") +
  geom_hline(yintercept=-log10(qval), col="red")
g1

g1 <- ggplot(data = res, aes(x=logFC, y=-log10(adj.P.Val))) +
  geom_point() +
  theme_minimal() +
  geom_text_repel(data = res[(res$adj.P.Val < 0.4),], aes(x=logFC, y=-log10(adj.P.Val), label = symbol)) +
  scale_color_manual(values=c("blue", "black", "red")) +
  geom_vline(xintercept=c(-0.6, 0.6), col="red") +
  geom_hline(yintercept=-log10(qval), col="red")
g1

```



Down-expressed genes are those that are down-expressed in outcomes that lead to implantation
Up-expressed genes are those that are up-expressed in outcomes that lead to implantation